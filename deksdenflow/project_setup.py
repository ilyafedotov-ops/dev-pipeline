import os
import shutil
import sys
from pathlib import Path
from typing import Optional

from .codex import run_process

# Map of target paths -> template paths (relative to repo root of this starter)
BASE_FILES = {
    "docs/deksdenflow.md": "docs/deksdenflow.md",
    "docs/ci.md": "docs/ci.md",
    "prompts/project-init.prompt.md": "prompts/project-init.prompt.md",
    "prompts/protocol-new.prompt.md": "prompts/protocol-new.prompt.md",
    "prompts/protocol-resume.prompt.md": "prompts/protocol-resume.prompt.md",
    "prompts/protocol-review-merge.prompt.md": "prompts/protocol-review-merge.prompt.md",
    "prompts/protocol-review-merge-resume.prompt.md": "prompts/protocol-review-merge-resume.prompt.md",
    "prompts/protocol-pipeline.prompt.md": "prompts/protocol-pipeline.prompt.md",
    "prompts/project-setup.prompt.md": "prompts/project-setup.prompt.md",
    "prompts/repo-discovery.prompt.md": "prompts/repo-discovery.prompt.md",
    "prompts/java-testing.prompt.md": "prompts/java-testing.prompt.md",
    "scripts/codex_ci_bootstrap.py": "scripts/codex_ci_bootstrap.py",
    "scripts/quality_orchestrator.py": "scripts/quality_orchestrator.py",
    "prompts/quality-validator.prompt.md": "prompts/quality-validator.prompt.md",
    "schemas/protocol-planning.schema.json": "schemas/protocol-planning.schema.json",
    "scripts/protocol_pipeline.py": "scripts/protocol_pipeline.py",
    ".github/workflows/ci.yml": ".github/workflows/ci.yml",
    ".gitlab-ci.yml": ".gitlab-ci.yml",
    "scripts/ci/bootstrap.sh": "scripts/ci/bootstrap.sh",
    "scripts/ci/lint.sh": "scripts/ci/lint.sh",
    "scripts/ci/typecheck.sh": "scripts/ci/typecheck.sh",
    "scripts/ci/test.sh": "scripts/ci/test.sh",
    "scripts/ci/build.sh": "scripts/ci/build.sh",
}

PLACEHOLDER = (
    "# Generated placeholder\n\n"
    "This file was generated by project_setup.py because no template was found. "
    "Please replace with the starter content from the DeksdenFlow_Ilyas_Edition_1.0 starter."
)


def ensure_git_repo(base_branch: str, init_if_needed: bool) -> Path:
    try:
        out = run_process(["git", "rev-parse", "--show-toplevel"], capture_output=True, text=True)
        return Path(out.stdout.strip())
    except Exception:
        if not init_if_needed:
            print("Not a git repository. Re-run with --init-if-needed to git init.")
            sys.exit(1)
        print(f"Initializing git repository with base branch {base_branch}...")
        run_process(["git", "init", "-b", base_branch], capture_output=False, text=True)
        out = run_process(["git", "rev-parse", "--show-toplevel"], capture_output=True, text=True)
        return Path(out.stdout.strip())


def ensure_remote_origin(repo_root: Path) -> None:
    try:
        run_process(["git", "remote", "get-url", "origin"], cwd=repo_root, capture_output=True, text=True)
    except Exception:
        print("Warning: no remote 'origin' configured. Add one with `git remote add origin <url>`.")


def ensure_base_branch(repo_root: Path, base_branch: str) -> None:
    try:
        run_process(
            ["git", "show-ref", "--verify", f"refs/heads/{base_branch}"],
            cwd=repo_root,
            capture_output=True,
            text=True,
        )
    except Exception:
        print(f"Warning: base branch '{base_branch}' does not exist locally. Create it or fetch it before running pipelines.")


def copy_if_missing(target: Path, source: Path) -> None:
    if target.exists():
        return
    target.parent.mkdir(parents=True, exist_ok=True)
    if source.is_file():
        shutil.copyfile(source, target)
        if source.stat().st_mode & 0o111:
            target.chmod(source.stat().st_mode)
        print(f"Created {target} from template.")
    else:
        target.write_text(PLACEHOLDER, encoding="utf-8")
        print(f"Created placeholder {target} (template missing).")


def make_executable(path: Path) -> None:
    try:
        mode = path.stat().st_mode
        path.chmod(mode | 0o111)
    except FileNotFoundError:
        pass


def ensure_assets(repo_root: Path) -> None:
    script_dir = Path(__file__).resolve().parent
    template_root = script_dir.parent
    for rel_target, rel_source in BASE_FILES.items():
        target = repo_root / rel_target
        source = template_root / rel_source
        copy_if_missing(target, source)
    for name in ["bootstrap.sh", "lint.sh", "typecheck.sh", "test.sh", "build.sh"]:
        make_executable(repo_root / "scripts" / "ci" / name)


def clone_repo(url: str, target_dir: Path) -> Path:
    if target_dir.exists():
        print(f"Clone target {target_dir} already exists. Using existing directory.")
        return target_dir
    target_dir.parent.mkdir(parents=True, exist_ok=True)
    print(f"Cloning {url} into {target_dir} ...")
    run_process(["git", "clone", url, str(target_dir)], capture_output=False, text=True)
    return target_dir


def run_codex_discovery(
    repo_root: Path,
    model: str,
    prompt_file: Optional[Path] = None,
    sandbox: str = "workspace-write",
    skip_git_check: bool = True,
    strict: bool = False,
) -> None:
    """
    Run Codex discovery (repo analysis + CI suggestions) with the repo-discovery prompt.

    strict=False (default) matches the setup script behavior: if codex or the prompt
    is missing, print a warning and return. strict=True raises FileNotFoundError in
    those cases so CLIs can fail fast.
    """
    if shutil.which("codex") is None:
        msg = "codex CLI not found; skipping discovery."
        if strict:
            raise FileNotFoundError(msg)
        print(msg)
        return

    prompt_path = prompt_file if prompt_file else repo_root / "prompts" / "repo-discovery.prompt.md"
    if not prompt_path.is_file():
        msg = f"repo-discovery prompt not found at {prompt_path}; skipping discovery."
        if strict:
            raise FileNotFoundError(msg)
        print(msg)
        return

    print(f"Running discovery with codex model {model} ...")
    prompt_text = prompt_path.read_text(encoding="utf-8")

    cmd = [
        "codex",
        "exec",
        "-m",
        model,
        "--cd",
        str(repo_root),
        "--sandbox",
        sandbox,
    ]
    if skip_git_check:
        cmd.append("--skip-git-repo-check")
    cmd.append("-")

    run_process(
        cmd,
        cwd=repo_root,
        capture_output=False,
        text=True,
        check=True,
        input_text=prompt_text,
    )

"""
DevGodzilla Cursor Editor Engine

Engine adapter for Cursor IDE integration.
"""

import subprocess
from pathlib import Path
from typing import Optional

from devgodzilla.engines.interface import (
    EngineInterface,
    EngineMetadata,
    EngineRequest,
    EngineResult,
    EngineCapability,
)


class CursorEngine(EngineInterface):
    """
    Engine adapter for Cursor Editor.
    
    Uses Cursor's command-line interface for task execution.
    Note: Cursor is an IDE-based agent and may require user interaction.
    """
    
    def __init__(
        self,
        model: str = "gpt-4",
        timeout: int = 600,
        command: str = "cursor",
    ) -> None:
        self._model = model
        self._timeout = timeout
        self._command = command
    
    @property
    def metadata(self) -> EngineMetadata:
        return EngineMetadata(
            engine_id="cursor",
            name="Cursor Editor",
            version="1.0.0",
            capabilities=[
                EngineCapability.CODE_GENERATION,
                EngineCapability.INTERACTIVE,
            ],
            default_model=self._model,
            supported_models=[
                "gpt-4",
                "gpt-4-turbo",
                "claude-3-opus",
            ],
        )
    
    def execute(self, request: EngineRequest) -> EngineResult:
        """Execute a task using Cursor's CLI."""
        try:
            # Check if cursor is available
            if not self.check_availability():
                return EngineResult(
                    success=False,
                    error="Cursor is not installed or not available in PATH",
                )
            
            # Build command for Cursor
            cwd = request.workspace_path or "."
            
            # Write task to a temporary file for Cursor to pick up
            task_file = Path(cwd) / ".cursor" / "commands" / "devgodzilla_task.md"
            task_file.parent.mkdir(parents=True, exist_ok=True)
            
            task_content = self._build_task_file(request)
            task_file.write_text(task_content)
            
            # For Cursor, we typically open the project and let user interact
            # This is a placeholder for headless execution
            cmd = [
                self._command,
                "--open",
                str(cwd),
            ]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30,  # Just opening, not waiting for completion
            )
            
            return EngineResult(
                success=True,
                output=f"Task written to {task_file}. Open Cursor to execute.",
                files_modified=[str(task_file)],
                metadata={
                    "model": request.model or self._model,
                    "engine": "cursor",
                    "mode": "interactive",
                },
            )
                
        except subprocess.TimeoutExpired:
            return EngineResult(
                success=False,
                error="Cursor launch timed out",
            )
        except Exception as e:
            return EngineResult(
                success=False,
                error=f"Cursor error: {e}",
            )
    
    def check_availability(self) -> bool:
        """Check if Cursor is available."""
        try:
            result = subprocess.run(
                [self._command, "--version"],
                capture_output=True,
                timeout=10,
            )
            return result.returncode == 0
        except Exception:
            return False
    
    def _build_task_file(self, request: EngineRequest) -> str:
        """Build the task file for Cursor."""
        parts = ["# DevGodzilla Task\n"]
        
        parts.append(f"## Task\n{request.prompt}\n")
        
        if request.context:
            parts.append(f"## Context\n{request.context}\n")
        
        if request.constraints:
            constraints = "\n".join(f"- {c}" for c in request.constraints)
            parts.append(f"## Constraints\n{constraints}\n")
        
        parts.append("\n---\n*Generated by DevGodzilla*\n")
        
        return "\n".join(parts)

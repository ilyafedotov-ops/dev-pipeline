#!/usr/bin/env python3
import argparse
import os
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Optional

# Map of target paths -> template paths (relative to repo root of this starter)
BASE_FILES = {
    "docs/deksdenflow.md": "docs/deksdenflow.md",
    "docs/ci.md": "docs/ci.md",
    "prompts/project-init.prompt.md": "prompts/project-init.prompt.md",
    "prompts/protocol-new.prompt.md": "prompts/protocol-new.prompt.md",
    "prompts/protocol-resume.prompt.md": "prompts/protocol-resume.prompt.md",
    "prompts/protocol-review-merge.prompt.md": "prompts/protocol-review-merge.prompt.md",
    "prompts/protocol-review-merge-resume.prompt.md": "prompts/protocol-review-merge-resume.prompt.md",
    "prompts/protocol-pipeline.prompt.md": "prompts/protocol-pipeline.prompt.md",
    "prompts/project-setup.prompt.md": "prompts/project-setup.prompt.md",
    "prompts/repo-discovery.prompt.md": "prompts/repo-discovery.prompt.md",
    "prompts/java-testing.prompt.md": "prompts/java-testing.prompt.md",
    "scripts/codex_ci_bootstrap.py": "scripts/codex_ci_bootstrap.py",
    "scripts/quality_orchestrator.py": "scripts/quality_orchestrator.py",
    "prompts/quality-validator.prompt.md": "prompts/quality-validator.prompt.md",
    "schemas/protocol-planning.schema.json": "schemas/protocol-planning.schema.json",
    "scripts/protocol_pipeline.py": "scripts/protocol_pipeline.py",
    ".github/workflows/ci.yml": ".github/workflows/ci.yml",
    ".gitlab-ci.yml": ".gitlab-ci.yml",
    "scripts/ci/bootstrap.sh": "scripts/ci/bootstrap.sh",
    "scripts/ci/lint.sh": "scripts/ci/lint.sh",
    "scripts/ci/typecheck.sh": "scripts/ci/typecheck.sh",
    "scripts/ci/test.sh": "scripts/ci/test.sh",
    "scripts/ci/build.sh": "scripts/ci/build.sh",
}

PLACEHOLDER = (
    "# Generated placeholder\n\n"
    "This file was generated by project_setup.py because no template was found. "
    "Please replace with the starter content from the DeksdenFlow_Ilyas_Edition_1.0 starter."
)


def run(cmd: list[str], cwd: Optional[Path] = None, check: bool = True, capture: bool = True) -> subprocess.CompletedProcess:
    return subprocess.run(
        cmd,
        cwd=str(cwd) if cwd else None,
        check=check,
        capture_output=capture,
        text=True,
    )


def ensure_git_repo(base_branch: str, init_if_needed: bool) -> Path:
    try:
        out = run(["git", "rev-parse", "--show-toplevel"])
        return Path(out.stdout.strip())
    except subprocess.CalledProcessError:
        if not init_if_needed:
            print("Not a git repository. Re-run with --init-if-needed to git init.")
            sys.exit(1)
        print(f"Initializing git repository with base branch {base_branch}...")
        run(["git", "init", "-b", base_branch], capture=False)
        out = run(["git", "rev-parse", "--show-toplevel"])
        return Path(out.stdout.strip())


def ensure_remote_origin(repo_root: Path) -> None:
    try:
        run(["git", "remote", "get-url", "origin"], cwd=repo_root)
    except subprocess.CalledProcessError:
        print("Warning: no remote 'origin' configured. Add one with `git remote add origin <url>`.")


def ensure_base_branch(repo_root: Path, base_branch: str) -> None:
    try:
        run(["git", "show-ref", "--verify", f"refs/heads/{base_branch}"], cwd=repo_root)
    except subprocess.CalledProcessError:
        print(f"Warning: base branch '{base_branch}' does not exist locally. Create it or fetch it before running pipelines.")


def copy_if_missing(target: Path, source: Path) -> None:
    if target.exists():
        return
    target.parent.mkdir(parents=True, exist_ok=True)
    if source.is_file():
        shutil.copyfile(source, target)
        if source.stat().st_mode & 0o111:
            target.chmod(source.stat().st_mode)
        print(f"Created {target} from template.")
    else:
        target.write_text(PLACEHOLDER, encoding="utf-8")
        print(f"Created placeholder {target} (template missing).")


def make_executable(path: Path) -> None:
    try:
        mode = path.stat().st_mode
        path.chmod(mode | 0o111)
    except FileNotFoundError:
        pass


def ensure_assets(repo_root: Path) -> None:
    script_dir = Path(__file__).resolve().parent
    template_root = script_dir.parent
    for rel_target, rel_source in BASE_FILES.items():
        target = repo_root / rel_target
        source = template_root / rel_source
        copy_if_missing(target, source)
    for name in ["bootstrap.sh", "lint.sh", "typecheck.sh", "test.sh", "build.sh"]:
        make_executable(repo_root / "scripts" / "ci" / name)


def clone_repo(url: str, target_dir: Path) -> Path:
    if target_dir.exists():
        print(f"Clone target {target_dir} already exists. Using existing directory.")
        return target_dir
    target_dir.parent.mkdir(parents=True, exist_ok=True)
    print(f"Cloning {url} into {target_dir} ...")
    run(["git", "clone", url, str(target_dir)], capture=False)
    return target_dir


def run_codex_discovery(repo_root: Path, model: str) -> None:
    if shutil.which("codex") is None:
        print("codex CLI not found; skipping discovery.")
        return
    prompt_file = repo_root / "prompts" / "repo-discovery.prompt.md"
    if not prompt_file.is_file():
        print("repo-discovery.prompt.md not found; skipping discovery.")
        return
    print(f"Running discovery with codex model {model} ...")
    # Feed the prompt file content to codex exec
    prompt_text = prompt_file.read_text(encoding="utf-8")
    run(
        [
            "codex",
            "exec",
            "-m",
            model,
            "--cd",
            str(repo_root),
            "--sandbox",
            "workspace-write",
            "--skip-git-repo-check",
            "-",
        ],
        cwd=repo_root,
        capture=False,
        check=True,
    )


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Prepare an existing or new project with DeksdenFlow_Ilyas_Edition_1.0 starter assets.",
    )
    parser.add_argument(
        "--base-branch",
        default="main",
        help="Base branch name (default: main).",
    )
    parser.add_argument(
        "--init-if-needed",
        action="store_true",
        help="Initialize git repo if not already initialized.",
    )
    parser.add_argument(
        "--clone-url",
        help="Optional: git clone this repository before preparing assets.",
    )
    parser.add_argument(
        "--clone-dir",
        help="Optional: directory name for clone (default: repo name from URL).",
    )
    parser.add_argument(
        "--run-discovery",
        action="store_true",
        help="Run Codex-driven repository discovery/config prep (requires codex CLI).",
    )
    parser.add_argument(
        "--discovery-model",
        help="Model for discovery (default from PROTOCOL_DISCOVERY_MODEL or codex-5.1-max).",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    repo_root: Path
    if args.clone_url:
        default_dir = (
            Path(args.clone_dir)
            if args.clone_dir
            else Path(args.clone_url.rstrip("/").split("/")[-1].replace(".git", ""))
        )
        repo_root = clone_repo(args.clone_url, default_dir.resolve())
    else:
        repo_root = ensure_git_repo(args.base_branch, args.init_if_needed)

    # Ensure subsequent commands operate inside the repo
    os.chdir(repo_root)
    repo_root = Path(os.getcwd())

    ensure_remote_origin(repo_root)
    ensure_base_branch(repo_root, args.base_branch)
    ensure_assets(repo_root)

    if args.run_discovery:
        discovery_model = args.discovery_model or os.environ.get("PROTOCOL_DISCOVERY_MODEL", "codex-5.1-max")
        run_codex_discovery(repo_root, discovery_model)

    print("Project setup completed. Review any placeholders and customize CI scripts for your stack.")


if __name__ == "__main__":
    main()

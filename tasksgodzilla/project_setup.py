import os
import re
import shutil
import sys
from pathlib import Path
from typing import Optional

from . import codex
from .logging import get_logger

log = get_logger(__name__)
DEFAULT_PROJECTS_ROOT = Path(os.environ.get("TASKSGODZILLA_PROJECTS_ROOT", "projects")).expanduser()

# Map of target paths -> template paths (relative to repo root of this starter)
BASE_FILES = {
    "docs/tasksgodzilla.md": "docs/tasksgodzilla.md",
    "docs/ci.md": "docs/ci.md",
    "prompts/project-init.prompt.md": "prompts/project-init.prompt.md",
    "prompts/protocol-new.prompt.md": "prompts/protocol-new.prompt.md",
    "prompts/protocol-resume.prompt.md": "prompts/protocol-resume.prompt.md",
    "prompts/protocol-review-merge.prompt.md": "prompts/protocol-review-merge.prompt.md",
    "prompts/protocol-review-merge-resume.prompt.md": "prompts/protocol-review-merge-resume.prompt.md",
    "prompts/protocol-pipeline.prompt.md": "prompts/protocol-pipeline.prompt.md",
    "prompts/project-setup.prompt.md": "prompts/project-setup.prompt.md",
    "prompts/repo-discovery.prompt.md": "prompts/repo-discovery.prompt.md",
    "prompts/java-testing.prompt.md": "prompts/java-testing.prompt.md",
    "scripts/codex_ci_bootstrap.py": "scripts/codex_ci_bootstrap.py",
    "scripts/quality_orchestrator.py": "scripts/quality_orchestrator.py",
    "prompts/quality-validator.prompt.md": "prompts/quality-validator.prompt.md",
    "schemas/protocol-planning.schema.json": "schemas/protocol-planning.schema.json",
    "scripts/protocol_pipeline.py": "scripts/protocol_pipeline.py",
    ".github/workflows/ci.yml": ".github/workflows/ci.yml",
    ".gitlab-ci.yml": ".gitlab-ci.yml",
    "scripts/ci/bootstrap.sh": "scripts/ci/bootstrap.sh",
    "scripts/ci/lint.sh": "scripts/ci/lint.sh",
    "scripts/ci/typecheck.sh": "scripts/ci/typecheck.sh",
    "scripts/ci/test.sh": "scripts/ci/test.sh",
    "scripts/ci/build.sh": "scripts/ci/build.sh",
}

PLACEHOLDER = (
    "# Generated placeholder\n\n"
    "This file was generated by project_setup.py because no template was found. "
    "Please replace with the starter content from the TasksGodzilla_Ilyas_Edition_1.0 starter."
)


def ensure_git_repo(base_branch: str, init_if_needed: bool) -> Path:
    try:
        out = codex.run_process(["git", "rev-parse", "--show-toplevel"], capture_output=True, text=True)
        return Path(out.stdout.strip())
    except Exception:
        if not init_if_needed:
            log.error("git_repo_missing", extra={"init_if_needed": init_if_needed, "cwd": str(Path.cwd())})
            sys.exit(1)
        log.info("git_repo_init", extra={"base_branch": base_branch})
        codex.run_process(["git", "init", "-b", base_branch], capture_output=False, text=True)
        out = codex.run_process(["git", "rev-parse", "--show-toplevel"], capture_output=True, text=True)
        return Path(out.stdout.strip())


def ensure_remote_origin(repo_root: Path) -> None:
    try:
        codex.run_process(["git", "remote", "get-url", "origin"], cwd=repo_root, capture_output=True, text=True)
    except Exception:
        log.warning("git_origin_missing", extra={"repo_root": str(repo_root)})


def ensure_base_branch(repo_root: Path, base_branch: str) -> None:
    try:
        codex.run_process(
            ["git", "show-ref", "--verify", f"refs/heads/{base_branch}"],
            cwd=repo_root,
            capture_output=True,
            text=True,
        )
    except Exception:
        log.warning("base_branch_missing", extra={"repo_root": str(repo_root), "base_branch": base_branch})


def copy_if_missing(target: Path, source: Path) -> None:
    if target.exists():
        return
    target.parent.mkdir(parents=True, exist_ok=True)
    if source.is_file():
        shutil.copyfile(source, target)
        if source.stat().st_mode & 0o111:
            target.chmod(source.stat().st_mode)
        log.info("template_copied", extra={"target": str(target), "source": str(source)})
    else:
        target.write_text(PLACEHOLDER, encoding="utf-8")
        log.info("template_placeholder_created", extra={"target": str(target), "source": str(source)})


def make_executable(path: Path) -> None:
    try:
        mode = path.stat().st_mode
        path.chmod(mode | 0o111)
    except FileNotFoundError:
        pass


def ensure_assets(repo_root: Path) -> None:
    script_dir = Path(__file__).resolve().parent
    template_root = script_dir.parent
    for rel_target, rel_source in BASE_FILES.items():
        target = repo_root / rel_target
        source = template_root / rel_source
        copy_if_missing(target, source)
    for name in ["bootstrap.sh", "lint.sh", "typecheck.sh", "test.sh", "build.sh"]:
        make_executable(repo_root / "scripts" / "ci" / name)


def _repo_name_from_url(git_url: str, fallback: Optional[str] = None) -> str:
    tail = git_url.rstrip("/").split("/")[-1] if git_url else ""
    if tail.endswith(".git"):
        tail = tail[:-4]
    return tail or (fallback or "project")


def _namespace_from_git_url(git_url: str, project_name: Optional[str], base_root: Path) -> Path:
    """
    Build a namespaced path (host/owner/repo) for remote URLs.
    Falls back to project_name/repo_name when parsing fails.
    """
    root = base_root
    try:
        if "://" in git_url:
            from urllib.parse import urlparse

            parsed = urlparse(git_url)
            host = parsed.hostname or "unknown"
            path = parsed.path.strip("/")
        elif git_url.startswith("git@"):
            m = re.match(r"git@([^:]+):(.+)", git_url)
            host = m.group(1) if m else "unknown"
            path = m.group(2) if m else _repo_name_from_url(git_url, project_name)
        else:
            return root / _repo_name_from_url(git_url, project_name)
        parts = [p for p in path.split("/") if p]
        if parts and parts[-1].endswith(".git"):
            parts[-1] = parts[-1][:-4]
        if len(parts) >= 2:
            return root / host / parts[0] / parts[1]
        if parts:
            return root / host / parts[0]
    except Exception:
        pass
    return root / _repo_name_from_url(git_url, project_name)


def _projects_root(projects_root: Optional[Path]) -> Path:
    """
    Normalize the projects root, defaulting to TASKSGODZILLA_PROJECTS_ROOT or ./projects.
    """
    return (Path(projects_root) if projects_root else DEFAULT_PROJECTS_ROOT).expanduser()


def local_repo_dir(
    git_url: str,
    project_name: Optional[str] = None,
    projects_root: Optional[Path] = None,
    *,
    project_id: Optional[int] = None,
) -> Path:
    """
    Derive a local path for a repository.

    Resolution order:
    1) If git_url is already a local path, return it unchanged.
    2) When a project_id is provided, prefer projects/<project_id>/<repo_name>.
    3) Fallback to host/owner/repo namespacing for remote URLs, or repo_name under projects_root.
    """
    url_path = Path(git_url).expanduser()
    if url_path.exists():
        return url_path

    base_root = _projects_root(projects_root)
    repo_name = _repo_name_from_url(git_url, project_name)

    if project_id is not None:
        target = base_root / str(project_id) / repo_name
    elif "github" in git_url or "gitlab" in git_url or git_url.startswith("git@"):
        target = _namespace_from_git_url(git_url, project_name, base_root)
    else:
        target = base_root / repo_name

    target = target.resolve()
    target.parent.mkdir(parents=True, exist_ok=True)
    return target


def auto_clone_enabled() -> bool:
    return os.environ.get("TASKSGODZILLA_AUTO_CLONE", "true").lower() in ("1", "true", "yes", "on")


def prefer_github_ssh() -> bool:
    return os.environ.get("TASKSGODZILLA_GH_SSH", "true").lower() in ("1", "true", "yes", "on")


def github_ssh_url(git_url: str) -> Optional[str]:
    """
    Convert https://github.com/owner/repo(.git) to git@github.com:owner/repo.git.
    """
    m = re.match(r"https?://github.com/([^/]+/[^/]+?)(?:\.git)?$", git_url)
    if not m:
        return None
    return f"git@github.com:{m.group(1)}.git"


def configure_git_remote(repo_root: Path, git_url: str, prefer_ssh_remote: bool = False) -> Optional[str]:
    """
    Ensure origin remote exists and optionally rewrite to SSH for GitHub.
    Returns the final origin URL.
    """
    origin_url = None
    try:
        out = codex.run_process(["git", "remote", "get-url", "origin"], cwd=repo_root, capture_output=True, text=True)
        origin_url = out.stdout.strip()
    except Exception:
        try:
            codex.run_process(["git", "remote", "add", "origin", git_url], cwd=repo_root, capture_output=True, text=True)
            origin_url = git_url
        except Exception:
            return None

    if prefer_ssh_remote:
        ssh_url = github_ssh_url(origin_url or git_url)
        if ssh_url and ssh_url != origin_url:
            codex.run_process(["git", "remote", "set-url", "origin", ssh_url], cwd=repo_root, capture_output=True, text=True)
            origin_url = ssh_url
    return origin_url


def configure_git_identity(repo_root: Path, user: Optional[str], email: Optional[str]) -> bool:
    """
    Configure git user.name/user.email when provided. Returns True when set.
    """
    if not user or not email:
        return False
    codex.run_process(["git", "config", "user.name", user], cwd=repo_root, capture_output=True, text=True)
    codex.run_process(["git", "config", "user.email", email], cwd=repo_root, capture_output=True, text=True)
    return True


def clone_repo(url: str, target_dir: Path) -> Path:
    if target_dir.exists():
        log.info("clone_target_exists", extra={"target_dir": str(target_dir)})
        return target_dir
    target_dir.parent.mkdir(parents=True, exist_ok=True)
    log.info("clone_repo", extra={"url": url, "target_dir": str(target_dir)})
    codex.run_process(["git", "clone", url, str(target_dir)], capture_output=False, text=True)
    return target_dir


def ensure_local_repo(
    git_url: str,
    project_name: Optional[str] = None,
    *,
    projects_root: Optional[Path] = None,
    project_id: Optional[int] = None,
    clone_if_missing: Optional[bool] = None,
) -> Path:
    """
    Return a local path for the repository, cloning it if it does not already exist.

    clone_if_missing defaults to the TASKSGODZILLA_AUTO_CLONE env flag (true by default).
    Raises FileNotFoundError when cloning is disabled and the repo is missing.
    """
    target = local_repo_dir(git_url, project_name, projects_root=projects_root, project_id=project_id)
    if target.exists():
        return target
    should_clone = auto_clone_enabled() if clone_if_missing is None else clone_if_missing
    if not should_clone:
        raise FileNotFoundError(f"Repository not present locally at {target}")
    return clone_repo(git_url, target)


def run_codex_discovery(
    repo_root: Path,
    model: str,
    prompt_file: Optional[Path] = None,
    sandbox: str = "workspace-write",
    skip_git_check: bool = True,
    strict: bool = False,
    timeout_seconds: Optional[int] = None,
) -> None:
    """
    Run Codex discovery (repo analysis + CI suggestions) with the repo-discovery prompt.

    strict=False (default) matches the setup script behavior: if codex or the prompt
    is missing, print a warning and return. strict=True raises FileNotFoundError in
    those cases so CLIs can fail fast.
    """
    if shutil.which("codex") is None:
        msg = "codex CLI not found; skipping discovery."
        if strict:
            log.error("codex_cli_missing", extra={"repo_root": str(repo_root), "model": model})
            raise FileNotFoundError(msg)
        log.warning("codex_cli_missing", extra={"repo_root": str(repo_root), "model": model})
        return

    prompt_path = prompt_file if prompt_file else repo_root / "prompts" / "repo-discovery.prompt.md"
    if not prompt_path.is_file():
        msg = f"repo-discovery prompt not found at {prompt_path}; skipping discovery."
        if strict:
            log.error("discovery_prompt_missing", extra={"prompt_path": str(prompt_path), "repo_root": str(repo_root)})
            raise FileNotFoundError(msg)
        log.warning("discovery_prompt_missing", extra={"prompt_path": str(prompt_path), "repo_root": str(repo_root)})
        return

    log.info(
        "run_codex_discovery",
        extra={
            "repo_root": str(repo_root),
            "model": model,
            "prompt_path": str(prompt_path),
            "sandbox": sandbox,
            "strict": strict,
        },
    )
    prompt_text = prompt_path.read_text(encoding="utf-8")

    cmd = [
        "codex",
        "exec",
        "-m",
        model,
        "--cd",
        str(repo_root),
        "--sandbox",
        sandbox,
    ]
    if skip_git_check:
        cmd.append("--skip-git-repo-check")
    cmd.append("-")

    run_kwargs = {
        "cwd": repo_root,
        "capture_output": False,
        "text": True,
        "check": True,
        "input_text": prompt_text,
    }
    if timeout_seconds is not None:
        run_kwargs["timeout"] = timeout_seconds
    codex.run_process(cmd, **run_kwargs)
    log.info("codex_discovery_complete", extra={"repo_root": str(repo_root), "model": model})

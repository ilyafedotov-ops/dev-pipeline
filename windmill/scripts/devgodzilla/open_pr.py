"""
Open PR Script

Create GitHub or GitLab Pull/Merge Request for completed protocol.

Args:
    protocol_run_id: Protocol run ID
    title: PR title
    description: PR description (auto-generated if not provided)
    draft: Create as draft PR

Returns:
    pr_url: URL of created PR/MR
    pr_number: PR/MR number
    provider: github or gitlab
"""

import os
import subprocess
from pathlib import Path
from datetime import datetime
import json

# Try to import httpx for API calls
try:
    import httpx
    HTTPX_AVAILABLE = True
except ImportError:
    import urllib.request
    import urllib.error
    HTTPX_AVAILABLE = False

# Import DevGodzilla services if available
try:
    from devgodzilla.db import get_database
    DEVGODZILLA_AVAILABLE = True
except ImportError:
    DEVGODZILLA_AVAILABLE = False


def main(
    protocol_run_id: int,
    title: str = "",
    description: str = "",
    draft: bool = False,
) -> dict:
    """Create PR/MR for protocol."""
    
    start_time = datetime.now()
    
    # Get protocol and project info
    protocol_info = _get_protocol_info(protocol_run_id)
    if not protocol_info:
        return {"error": f"Protocol {protocol_run_id} not found"}
    
    project_path = Path(protocol_info.get("worktree_path") or protocol_info["local_path"])
    branch_name = protocol_info["branch_name"]
    base_branch = protocol_info.get("base_branch", "main")
    git_url = protocol_info["git_url"]
    
    # Generate title and description if not provided
    if not title:
        title = f"[DevGodzilla] {protocol_info.get('protocol_name', f'Protocol {protocol_run_id}')}"
    
    if not description:
        description = _generate_description(protocol_run_id, protocol_info, project_path)
    
    # Step 1: Ensure all changes are committed
    commit_result = _commit_changes(project_path, f"DevGodzilla: Complete protocol {protocol_run_id}")
    
    # Step 2: Push branch
    push_result = _push_branch(project_path, branch_name)
    if not push_result.get("success"):
        return {"error": f"Push failed: {push_result.get('error')}"}
    
    # Step 3: Detect provider and create PR
    provider = _detect_provider(git_url)
    
    if provider == "github":
        result = _create_github_pr(git_url, branch_name, base_branch, title, description, draft)
    elif provider == "gitlab":
        result = _create_gitlab_mr(git_url, branch_name, base_branch, title, description, draft)
    else:
        return {"error": f"Unsupported provider: {provider}"}
    
    if result.get("success"):
        # Update protocol with PR info
        _update_protocol_pr_info(protocol_run_id, result)
    
    result["duration_seconds"] = (datetime.now() - start_time).total_seconds()
    return result


def _get_protocol_info(protocol_run_id: int) -> dict | None:
    """Get protocol and project info from database."""
    
    if DEVGODZILLA_AVAILABLE:
        try:
            db = get_database()
            protocol = db.get_protocol_run(protocol_run_id)
            project = db.get_project(protocol.project_id)

            single_worktree = os.environ.get("DEVGODZILLA_SINGLE_WORKTREE", "true").lower() in ("1", "true", "yes", "on")
            shared_branch = os.environ.get("DEVGODZILLA_WORKTREE_BRANCH", "devgodzilla-worktree")
            branch_name = shared_branch if single_worktree else protocol.protocol_name

            return {
                "protocol_name": protocol.protocol_name,
                "branch_name": branch_name,
                "base_branch": protocol.base_branch or "main",
                "local_path": project.local_path,
                "worktree_path": protocol.worktree_path,
                "git_url": project.git_url,
            }
        except:
            pass
    
    # Fallback for demo
    demo_path = Path("/tmp/devgodzilla/repos")
    if demo_path.exists():
        repos = list(demo_path.iterdir())
        if repos:
            return {
                "protocol_name": f"Demo Protocol {protocol_run_id}",
                "branch_name": f"devgodzilla-{protocol_run_id}",
                "base_branch": "main",
                "local_path": str(repos[0]),
                "git_url": "https://github.com/example/repo",
            }
    
    return None


def _generate_description(protocol_run_id: int, protocol_info: dict, project_path: Path) -> str:
    """Generate PR description from protocol artifacts."""
    
    description = f"""## ðŸ¦– DevGodzilla Protocol #{protocol_run_id}

### Summary
This PR was generated by DevGodzilla AI development protocol.

**Protocol**: {protocol_info.get('protocol_name', 'N/A')}
**Branch**: `{protocol_info.get('branch_name', 'N/A')}`

"""
    
    # Try to include spec summary
    spec_path = project_path / "specs" / protocol_info.get('branch_name', '') / "spec.md"
    if spec_path.exists():
        spec_content = spec_path.read_text()
        # Extract first few lines
        lines = spec_content.split('\n')[:10]
        description += "### Feature Specification\n"
        description += "\n".join(lines[:5]) + "\n\n"
    
    # Add QA status placeholder
    description += """### QA Status
- [ ] Constitutional gates passed
- [ ] Tests pass
- [ ] Ready for review

---
*Generated by DevGodzilla*
"""
    
    return description


def _commit_changes(project_path: Path, message: str) -> dict:
    """Commit any uncommitted changes."""
    
    try:
        # Stage all changes
        subprocess.run(
            ["git", "add", "-A"],
            cwd=str(project_path),
            capture_output=True,
        )
        
        # Check if there are changes to commit
        status = subprocess.run(
            ["git", "status", "--porcelain"],
            cwd=str(project_path),
            capture_output=True,
            text=True,
        )
        
        if not status.stdout.strip():
            return {"success": True, "message": "No changes to commit"}
        
        # Commit
        result = subprocess.run(
            ["git", "commit", "-m", message],
            cwd=str(project_path),
            capture_output=True,
            text=True,
        )
        
        return {
            "success": result.returncode == 0,
            "message": result.stdout if result.returncode == 0 else result.stderr,
        }
        
    except Exception as e:
        return {"success": False, "error": str(e)}


def _push_branch(project_path: Path, branch_name: str) -> dict:
    """Push branch to remote."""
    
    try:
        result = subprocess.run(
            ["git", "push", "-u", "origin", branch_name],
            cwd=str(project_path),
            capture_output=True,
            text=True,
        )
        
        return {
            "success": result.returncode == 0,
            "error": result.stderr if result.returncode != 0 else None,
        }
        
    except Exception as e:
        return {"success": False, "error": str(e)}


def _detect_provider(git_url: str) -> str:
    """Detect Git provider from URL."""
    
    if "github.com" in git_url:
        return "github"
    elif "gitlab" in git_url:
        return "gitlab"
    elif "bitbucket" in git_url:
        return "bitbucket"
    else:
        return "unknown"


def _parse_github_url(git_url: str) -> tuple[str, str]:
    """Parse owner and repo from GitHub URL."""
    import re
    
    # Handle HTTPS URLs
    match = re.search(r'github\.com[:/]([^/]+)/([^/.]+)', git_url)
    if match:
        return match.group(1), match.group(2)
    
    return "", ""


def _create_github_pr(
    git_url: str,
    head_branch: str,
    base_branch: str,
    title: str,
    body: str,
    draft: bool,
) -> dict:
    """Create GitHub Pull Request."""
    
    owner, repo = _parse_github_url(git_url)
    if not owner or not repo:
        return {"success": False, "error": "Could not parse GitHub URL"}
    
    token = os.environ.get("GITHUB_TOKEN") or os.environ.get("GH_TOKEN")
    if not token:
        return {
            "success": False,
            "error": "No GitHub token found. Set GITHUB_TOKEN or GH_TOKEN env var.",
            "demo_mode": True,
            "pr_url": f"https://github.com/{owner}/{repo}/compare/{base_branch}...{head_branch}",
        }
    
    url = f"https://api.github.com/repos/{owner}/{repo}/pulls"
    data = {
        "title": title,
        "body": body,
        "head": head_branch,
        "base": base_branch,
        "draft": draft,
    }
    
    try:
        if HTTPX_AVAILABLE:
            response = httpx.post(
                url,
                json=data,
                headers={
                    "Authorization": f"Bearer {token}",
                    "Accept": "application/vnd.github.v3+json",
                },
            )
            
            if response.status_code == 201:
                result = response.json()
                return {
                    "success": True,
                    "provider": "github",
                    "pr_number": result["number"],
                    "pr_url": result["html_url"],
                    "status": "open",
                }
            else:
                return {"success": False, "error": response.text}
        else:
            # Fallback to urllib
            req = urllib.request.Request(
                url,
                data=json.dumps(data).encode(),
                headers={
                    "Authorization": f"Bearer {token}",
                    "Accept": "application/vnd.github.v3+json",
                    "Content-Type": "application/json",
                },
                method="POST",
            )
            
            with urllib.request.urlopen(req) as response:
                result = json.loads(response.read().decode())
                return {
                    "success": True,
                    "provider": "github",
                    "pr_number": result["number"],
                    "pr_url": result["html_url"],
                    "status": "open",
                }
                
    except Exception as e:
        return {"success": False, "error": str(e)}


def _create_gitlab_mr(
    git_url: str,
    source_branch: str,
    target_branch: str,
    title: str,
    description: str,
    draft: bool,
) -> dict:
    """Create GitLab Merge Request."""
    
    # GitLab MR creation would go here
    # Similar to GitHub but with different API
    
    return {
        "success": False,
        "error": "GitLab MR creation not yet implemented",
        "demo_mode": True,
    }


def _update_protocol_pr_info(protocol_run_id: int, pr_info: dict) -> None:
    """Update protocol with PR information."""
    
    if DEVGODZILLA_AVAILABLE:
        try:
            db = get_database()
            db.update_protocol_run(
                protocol_run_id,
                pr_url=pr_info.get("pr_url"),
                pr_number=pr_info.get("pr_number"),
                status="pr_opened",
            )
        except:
            pass
